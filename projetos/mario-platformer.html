<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO Meta Tags -->
    <title>Mario Platformer - Jogo React | Dev Brayan - Portfolio</title>
    <meta name="title" content="Mario Platformer - Jogo React | Dev Brayan">
    <meta name="description" content="Jogue Mario Platformer, um jogo de plataforma estilo Mario desenvolvido em React. Pule, colete moedas, elimine inimigos e complete o n√≠vel. Desenvolvido por Dev Brayan.">
    <meta name="description:en" content="Play Mario Platformer, a Mario-style platform game developed in React. Jump, collect coins, eliminate enemies and complete the level. Developed by Dev Brayan.">
    <meta name="keywords" content="Mario Platformer, Jogo React, Game React, Platform Game, Mario Game, React Game, Dev Brayan, Brayan Silveira, Portfolio Game, Interactive Game, Browser Game, HTML5 Game, Canvas Game, JavaScript Game, React Developer, Game Developer, Web Game, Online Game, Free Game, Play Game">
    <meta name="author" content="Brayan Rosa da Silveira - Dev Brayan">
    <meta name="robots" content="index, follow">
    <meta name="language" content="Portuguese, English">
    
    <!-- Multilingual Support -->
    <link rel="alternate" hreflang="pt-BR" href="https://brayansilver.github.io/projetos/mario-platformer.html">
    <link rel="alternate" hreflang="en" href="https://brayansilver.github.io/projetos/mario-platformer.html">
    <link rel="alternate" hreflang="x-default" href="https://brayansilver.github.io/projetos/mario-platformer.html">
    
    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Mario Platformer - Jogo React | Dev Brayan">
    <meta property="og:description" content="Jogue Mario Platformer, um jogo de plataforma estilo Mario desenvolvido em React. Desenvolvido por Dev Brayan.">
    <meta property="og:locale" content="pt_BR">
    <meta property="og:locale:alternate" content="en_US">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Mario Platformer - Jogo React | Dev Brayan">
    <meta name="twitter:description" content="Jogue Mario Platformer, um jogo de plataforma estilo Mario desenvolvido em React.">
    
    <!-- Performance Optimizations -->
    <link rel="preconnect" href="https://unpkg.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="dns-prefetch" href="https://cdn.tailwindcss.com">
    
    <!-- Load fonts asynchronously -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
    <noscript><link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet"></noscript>
    
    <!-- Load React and dependencies asynchronously -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js" async></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" async></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js" async></script>
    <script src="https://cdn.tailwindcss.com" async></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
            overflow: hidden;
        }
        #root {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            max-width: 100%;
            max-height: 100vh;
            width: auto !important;
            height: auto !important;
        }
        @media (max-width: 768px) {
            canvas {
                width: 100vw !important;
                height: auto !important;
            }
        }
        .touch-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
            pointer-events: none;
        }
        .touch-controls button {
            pointer-events: all;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid white;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        .touch-controls .dpad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 180px;
            height: 180px;
        }
        .touch-controls .dpad button {
            width: 58px;
            height: 58px;
            border-radius: 8px;
        }
        .touch-controls .dpad .up { grid-column: 2; grid-row: 1; }
        .touch-controls .dpad .left { grid-column: 1; grid-row: 2; }
        .touch-controls .dpad .down { grid-column: 2; grid-row: 3; }
        .touch-controls .dpad .right { grid-column: 3; grid-row: 2; }
        @media (min-width: 769px) {
            .touch-controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const MarioPlatformer = () => {
            const canvasRef = useRef(null);
            const gameLoopRef = useRef(null);
            const [gameState, setGameState] = useState('menu');
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(0);
            const [lives, setLives] = useState(3);
            const [isMobile, setIsMobile] = useState(false);
            const [canvasSize, setCanvasSize] = useState({ width: 800, height: 600 });
            
            const gameRef = useRef({
                player: { x: 100, y: 400, width: 40, height: 50, vx: 0, vy: 0, speed: 5, jumpPower: -15, onGround: false },
                platforms: [],
                enemies: [],
                coins: [],
                particles: [],
                keys: {},
                camera: { x: 0, y: 0 },
                level: 1
            });

            // Detect mobile and adjust canvas size
            useEffect(() => {
                const checkMobile = () => {
                    const mobile = window.innerWidth <= 768;
                    setIsMobile(mobile);
                    if (mobile) {
                        const maxWidth = window.innerWidth - 40;
                        const aspectRatio = 800 / 600;
                        const width = Math.min(maxWidth, 600);
                        const height = width / aspectRatio;
                        setCanvasSize({ width, height });
                    } else {
                        setCanvasSize({ width: 800, height: 600 });
                    }
                };
                checkMobile();
                window.addEventListener('resize', checkMobile);
                return () => window.removeEventListener('resize', checkMobile);
            }, []);

            useEffect(() => {
                try {
                    const saved = localStorage.getItem('mario-platformer-highscore');
                    if (saved) {
                        setHighScore(parseInt(saved));
                    }
                } catch (error) {
                    console.log('No high score found');
                }
            }, []);

            const saveHighScore = (score) => {
                try {
                    localStorage.setItem('mario-platformer-highscore', score.toString());
                } catch (error) {
                    console.error('Failed to save high score:', error);
                }
            };

            const initLevel = () => {
                const game = gameRef.current;
                game.platforms = [];
                game.enemies = [];
                game.coins = [];
                game.particles = [];
                
                // Criar plataformas
                for (let i = 0; i < 20; i++) {
                    game.platforms.push({
                        x: i * 200,
                        y: 500 - (i % 3) * 100,
                        width: 180,
                        height: 20,
                        color: '#8B4513'
                    });
                }
                
                // Criar moedas
                for (let i = 0; i < 15; i++) {
                    game.coins.push({
                        x: 150 + i * 250,
                        y: 300 + Math.sin(i) * 100,
                        width: 30,
                        height: 30,
                        collected: false,
                        rotation: 0
                    });
                }
                
                // Criar inimigos
                for (let i = 0; i < 8; i++) {
                    game.enemies.push({
                        x: 300 + i * 400,
                        y: 450,
                        width: 35,
                        height: 35,
                        vx: -2,
                        direction: -1
                    });
                }
                
                game.player.x = 100;
                game.player.y = 400;
                game.player.vx = 0;
                game.player.vy = 0;
                game.camera.x = 0;
            };

            const startGame = () => {
                setGameState('playing');
                setScore(0);
                setLives(3);
                gameRef.current.level = 1;
                initLevel();
            };

            const createParticles = (x, y, color, count = 10) => {
                const game = gameRef.current;
                for (let i = 0; i < count; i++) {
                    game.particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 30,
                        color,
                        size: Math.random() * 4 + 2
                    });
                }
            };

            const checkCollision = (a, b) => {
                return a.x < b.x + b.width &&
                       a.x + a.width > b.x &&
                       a.y < b.y + b.height &&
                       a.y + a.height > b.y;
            };

            const gameLoop = useCallback(() => {
                if (gameState !== 'playing') return;

                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const game = gameRef.current;
                const { player, keys } = game;

                // Clear canvas
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw clouds
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                for (let i = 0; i < 5; i++) {
                    const x = (i * 300 + game.camera.x * 0.3) % (canvas.width + 200) - 100;
                    const y = 50 + i * 30;
                    ctx.beginPath();
                    ctx.arc(x, y, 30, 0, Math.PI * 2);
                    ctx.arc(x + 40, y, 35, 0, Math.PI * 2);
                    ctx.arc(x + 80, y, 30, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Player movement
                if (keys.ArrowLeft || keys.a || keys.A) {
                    player.vx = -player.speed;
                } else if (keys.ArrowRight || keys.d || keys.D) {
                    player.vx = player.speed;
                } else {
                    player.vx *= 0.8;
                }

                if ((keys.ArrowUp || keys.w || keys.W || keys[' ']) && player.onGround) {
                    player.vy = player.jumpPower;
                    player.onGround = false;
                }

                // Apply gravity
                player.vy += 0.8;
                if (player.vy > 15) player.vy = 15;

                // Update player position
                player.x += player.vx;
                player.y += player.vy;

                // Check platform collisions
                player.onGround = false;
                game.platforms.forEach(platform => {
                    if (checkCollision(player, platform)) {
                        if (player.vy > 0 && player.y < platform.y) {
                            player.y = platform.y - player.height;
                            player.vy = 0;
                            player.onGround = true;
                        }
                    }
                });

                // Update camera
                game.camera.x = player.x - canvas.width / 3;

                // Draw platforms
                game.platforms.forEach(platform => {
                    const px = platform.x - game.camera.x;
                    if (px > -100 && px < canvas.width + 100) {
                        ctx.fillStyle = platform.color;
                        ctx.fillRect(px, platform.y - game.camera.y, platform.width, platform.height);
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(px, platform.y - game.camera.y, platform.width, 5);
                    }
                });

                // Update and draw enemies
                game.enemies = game.enemies.filter(enemy => {
                    enemy.x += enemy.vx;
                    
                    // Bounce off platforms
                    let onPlatform = false;
                    game.platforms.forEach(platform => {
                        if (checkCollision(enemy, platform)) {
                            if (enemy.y < platform.y) {
                                enemy.y = platform.y - enemy.height;
                                onPlatform = true;
                            }
                        }
                    });
                    
                    if (!onPlatform) {
                        enemy.vy += 0.8;
                        enemy.y += enemy.vy;
                    } else {
                        enemy.vy = 0;
                    }
                    
                    // Change direction at edges
                    if (enemy.x < game.camera.x - 50 || enemy.x > game.camera.x + canvas.width + 50) {
                        return false;
                    }
                    
                    const ex = enemy.x - game.camera.x;
                    if (ex > -50 && ex < canvas.width + 50) {
                        ctx.fillStyle = '#8B0000';
                        ctx.fillRect(ex, enemy.y - game.camera.y, enemy.width, enemy.height);
                        ctx.fillStyle = '#FF0000';
                        ctx.fillRect(ex + 5, enemy.y - game.camera.y + 5, enemy.width - 10, enemy.height - 10);
                    }
                    
                    // Check collision with player
                    if (checkCollision(player, enemy)) {
                        if (player.vy > 0 && player.y < enemy.y) {
                            // Player jumps on enemy
                            createParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, '#8B0000', 15);
                            setScore(s => s + 50);
                            return false;
                        } else {
                            // Player hit by enemy
                            setLives(l => {
                                const newLives = l - 1;
                                if (newLives <= 0) {
                                    setGameState('gameOver');
                                    if (score > highScore) {
                                        setHighScore(score);
                                        saveHighScore(score);
                                    }
                                }
                                return newLives;
                            });
                            createParticles(player.x + player.width / 2, player.y + player.height / 2, '#FF0000', 20);
                            player.x = 100;
                            player.y = 400;
                            player.vx = 0;
                            player.vy = 0;
                        }
                    }
                    
                    return true;
                });

                // Update and draw coins
                game.coins.forEach(coin => {
                    if (!coin.collected) {
                        coin.rotation += 0.1;
                        const cx = coin.x - game.camera.x;
                        const cy = coin.y - game.camera.y;
                        
                        if (cx > -50 && cx < canvas.width + 50) {
                            ctx.save();
                            ctx.translate(cx + coin.width / 2, cy + coin.height / 2);
                            ctx.rotate(coin.rotation);
                            ctx.fillStyle = '#FFD700';
                            ctx.shadowColor = '#FFD700';
                            ctx.shadowBlur = 10;
                            ctx.beginPath();
                            ctx.arc(0, 0, coin.width / 2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#FFA500';
                            ctx.beginPath();
                            ctx.arc(0, 0, coin.width / 3, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                            ctx.restore();
                        }
                        
                        if (checkCollision(player, coin)) {
                            coin.collected = true;
                            createParticles(coin.x + coin.width / 2, coin.y + coin.height / 2, '#FFD700', 10);
                            setScore(s => s + 100);
                        }
                    }
                });

                // Update and draw particles
                game.particles = game.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    
                    if (p.life > 0) {
                        const px = p.x - game.camera.x;
                        const py = p.y - game.camera.y;
                        if (px > -10 && px < canvas.width + 10) {
                            ctx.fillStyle = p.color;
                            ctx.globalAlpha = p.life / 30;
                            ctx.fillRect(px, py, p.size, p.size);
                            ctx.globalAlpha = 1;
                        }
                        return true;
                    }
                    return false;
                });

                // Draw player
                const px = player.x - game.camera.x;
                const py = player.y - game.camera.y;
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(px, py, player.width, player.height);
                ctx.fillStyle = '#0000FF';
                ctx.fillRect(px + 5, py + 5, player.width - 10, 15);
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(px + 10, py + 20, 20, 20);

                // Check if player fell
                if (player.y > canvas.height + 200) {
                    setLives(l => {
                        const newLives = l - 1;
                        if (newLives <= 0) {
                            setGameState('gameOver');
                            if (score > highScore) {
                                setHighScore(score);
                                saveHighScore(score);
                            }
                        }
                        return newLives;
                    });
                    player.x = 100;
                    player.y = 400;
                    player.vx = 0;
                    player.vy = 0;
                }

                gameLoopRef.current = requestAnimationFrame(gameLoop);
            }, [gameState, score, highScore]);

            useEffect(() => {
                if (gameState === 'playing') {
                    gameLoopRef.current = requestAnimationFrame(gameLoop);
                }
                return () => {
                    if (gameLoopRef.current) {
                        cancelAnimationFrame(gameLoopRef.current);
                    }
                };
            }, [gameState, gameLoop]);

            // Touch controls handlers
            const handleTouchStart = (direction) => {
                const game = gameRef.current;
                if (direction === 'left' || direction === 'a') game.keys.ArrowLeft = true;
                if (direction === 'right' || direction === 'd') game.keys.ArrowRight = true;
                if (direction === 'jump' || direction === 'w' || direction === ' ') {
                    if (game.player.onGround) {
                        game.player.vy = game.player.jumpPower;
                        game.player.onGround = false;
                    }
                }
            };

            const handleTouchEnd = (direction) => {
                const game = gameRef.current;
                if (direction === 'left' || direction === 'a') game.keys.ArrowLeft = false;
                if (direction === 'right' || direction === 'd') game.keys.ArrowRight = false;
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'a', 'A', 'd', 'D', 'w', 'W', ' '].includes(e.key)) {
                        e.preventDefault();
                    }
                    gameRef.current.keys[e.key] = true;
                };

                const handleKeyUp = (e) => {
                    gameRef.current.keys[e.key] = false;
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);

                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, [gameState]);

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-400 via-blue-500 to-blue-600 flex items-center justify-center p-4" style={{ fontFamily: "'Press Start 2P', cursive" }}>
                    <div className="relative">
                        {/* HUD */}
                        <div className="absolute top-0 left-0 right-0 flex justify-between items-start p-4 text-white z-10 text-xs">
                            <div className="space-y-2">
                                <div className="flex items-center gap-2">
                                    <span className="text-yellow-400">üí∞</span>
                                    <span className="text-white">{score}</span>
                                </div>
                                <div className="flex gap-1">
                                    {[...Array(lives)].map((_, i) => (
                                        <div key={i} className="w-6 h-6 bg-red-500 border-2 border-red-300" />
                                    ))}
                                </div>
                            </div>
                            
                            <div className="text-right space-y-2">
                                <div className="text-xs text-gray-300">RECORDE</div>
                                <div className="text-yellow-400">{highScore}</div>
                            </div>
                        </div>

                        <canvas
                            ref={canvasRef}
                            width={canvasSize.width}
                            height={canvasSize.height}
                            className="border-4 border-blue-600 shadow-2xl bg-blue-300"
                            style={{ boxShadow: '0 0 30px rgba(37, 99, 235, 0.5)', maxWidth: '100%', height: 'auto' }}
                        />

                        {/* Touch Controls for Mobile */}
                        {isMobile && gameState === 'playing' && (
                            <div className="touch-controls">
                                <div className="dpad">
                                    <button 
                                        className="up"
                                        onTouchStart={(e) => { e.preventDefault(); handleTouchStart('jump'); }}
                                        onMouseDown={() => handleTouchStart('jump')}
                                    >‚Üë</button>
                                    <button 
                                        className="left"
                                        onTouchStart={(e) => { e.preventDefault(); handleTouchStart('left'); }}
                                        onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd('left'); }}
                                        onMouseDown={() => handleTouchStart('left')}
                                        onMouseUp={() => handleTouchEnd('left')}
                                        onMouseLeave={() => handleTouchEnd('left')}
                                    >‚Üê</button>
                                    <div></div>
                                    <button 
                                        className="right"
                                        onTouchStart={(e) => { e.preventDefault(); handleTouchStart('right'); }}
                                        onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd('right'); }}
                                        onMouseDown={() => handleTouchStart('right')}
                                        onMouseUp={() => handleTouchEnd('right')}
                                        onMouseLeave={() => handleTouchEnd('right')}
                                    >‚Üí</button>
                                </div>
                            </div>
                        )}

                        {/* Menu Overlay */}
                        {gameState === 'menu' && (
                            <div className="absolute inset-0 bg-black bg-opacity-90 flex items-center justify-center backdrop-blur-sm">
                                <div className="text-center space-y-8 p-8">
                                    <h1 className="text-5xl text-transparent bg-clip-text bg-gradient-to-r from-red-500 via-yellow-400 to-red-500 animate-pulse">
                                        MARIO<br/>PLATFORMER
                                    </h1>
                                    
                                    <div className="space-y-4 text-xs text-blue-300">
                                        <p>A/D ou SETAS - Mover</p>
                                        <p>W ou SETA CIMA ou ESPA√áO - Pular</p>
                                        <p>Colete moedas e elimine inimigos!</p>
                                    </div>

                                    <button
                                        onClick={startGame}
                                        className="bg-gradient-to-r from-red-500 to-red-600 hover:from-red-400 hover:to-red-500 text-white px-8 py-4 text-sm border-4 border-white shadow-lg transition-all hover:scale-110 active:scale-95"
                                        style={{ boxShadow: '0 0 20px rgba(239, 68, 68, 0.5)' }}
                                    >
                                        INICIAR
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Game Over Overlay */}
                        {gameState === 'gameOver' && (
                            <div className="absolute inset-0 bg-black bg-opacity-90 flex items-center justify-center backdrop-blur-sm">
                                <div className="text-center space-y-6 p-8">
                                    <h2 className="text-4xl text-red-500 animate-pulse">GAME OVER</h2>
                                    
                                    <div className="space-y-4 text-xl">
                                        <div>
                                            <div className="text-xs text-gray-400 mb-1">PONTUA√á√ÉO</div>
                                            <div className="text-yellow-400">{score}</div>
                                        </div>
                                        
                                        {score === highScore && score > 0 && (
                                            <div className="text-yellow-400 text-sm animate-bounce">
                                                üèÜ NOVO RECORDE! üèÜ
                                            </div>
                                        )}
                                        
                                        <div>
                                            <div className="text-xs text-gray-400 mb-1">RECORDE</div>
                                            <div className="text-yellow-400">{highScore}</div>
                                        </div>
                                    </div>

                                    <div className="space-y-3 pt-4">
                                        <button
                                            onClick={startGame}
                                            className="block w-full bg-gradient-to-r from-green-600 to-green-700 hover:from-green-500 hover:to-green-600 text-white px-8 py-3 text-xs border-2 border-white transition-all hover:scale-105"
                                        >
                                            JOGAR NOVAMENTE
                                        </button>
                                        <button
                                            onClick={() => setGameState('menu')}
                                            className="block w-full bg-red-700 hover:bg-red-600 text-white px-8 py-3 text-xs border-2 border-red-400"
                                        >
                                            MENU
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        ReactDOM.render(React.createElement(MarioPlatformer), document.getElementById('root'));
    </script>
</body>
</html>

