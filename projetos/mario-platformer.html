<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO Meta Tags -->
    <title>Mario Platformer - Jogo React | Dev Brayan - Portfolio</title>
    <meta name="title" content="Mario Platformer - Jogo React | Dev Brayan">
    <meta name="description" content="Jogue Mario Platformer, um jogo de plataforma estilo Mario desenvolvido em React. Pule, colete moedas, elimine inimigos e complete o n√≠vel. Desenvolvido por Dev Brayan.">
    <meta name="description:en" content="Play Mario Platformer, a Mario-style platform game developed in React. Jump, collect coins, eliminate enemies and complete the level. Developed by Dev Brayan.">
    <meta name="keywords" content="Mario Platformer, Jogo React, Game React, Platform Game, Mario Game, React Game, Dev Brayan, Brayan Silveira, Portfolio Game, Interactive Game, Browser Game, HTML5 Game, Canvas Game, JavaScript Game, React Developer, Game Developer, Web Game, Online Game, Free Game, Play Game">
    <meta name="author" content="Brayan Rosa da Silveira - Dev Brayan">
    <meta name="robots" content="index, follow">
    <meta name="language" content="Portuguese, English">
    
    <!-- Multilingual Support -->
    <link rel="alternate" hreflang="pt-BR" href="https://brayansilver.github.io/projetos/mario-platformer.html">
    <link rel="alternate" hreflang="en" href="https://brayansilver.github.io/projetos/mario-platformer.html">
    <link rel="alternate" hreflang="x-default" href="https://brayansilver.github.io/projetos/mario-platformer.html">
    
    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Mario Platformer - Jogo React | Dev Brayan">
    <meta property="og:description" content="Jogue Mario Platformer, um jogo de plataforma estilo Mario desenvolvido em React. Desenvolvido por Dev Brayan.">
    <meta property="og:locale" content="pt_BR">
    <meta property="og:locale:alternate" content="en_US">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Mario Platformer - Jogo React | Dev Brayan">
    <meta name="twitter:description" content="Jogue Mario Platformer, um jogo de plataforma estilo Mario desenvolvido em React.">
    
    <!-- Performance Optimizations -->
    <link rel="preconnect" href="https://unpkg.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- Load fonts asynchronously -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
    <noscript><link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet"></noscript>
    
    <!-- Load React and dependencies in correct order -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
            overflow: hidden;
        }
        #root {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            max-width: 100%;
            max-height: 100vh;
            width: auto !important;
            height: auto !important;
        }
        @media (max-width: 768px) {
            canvas {
                width: 100vw !important;
                height: auto !important;
            }
        }
        .touch-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
            pointer-events: none;
        }
        .touch-controls button {
            pointer-events: all;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid white;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        .touch-controls .dpad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 180px;
            height: 180px;
        }
        .touch-controls .dpad button {
            width: 58px;
            height: 58px;
            border-radius: 8px;
        }
        .touch-controls .dpad .up { grid-column: 2; grid-row: 1; }
        .touch-controls .dpad .left { grid-column: 1; grid-row: 2; }
        .touch-controls .dpad .down { grid-column: 2; grid-row: 3; }
        .touch-controls .dpad .right { grid-column: 3; grid-row: 2; }
        @media (min-width: 769px) {
            .touch-controls {
                display: none;
            }
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
    </style>
</head>
<body>
    <div id="root">
        <div id="loading-screen" style="display: flex; align-items: center; justify-content: center; height: 100vh; background: linear-gradient(to bottom right, #60a5fa, #3b82f6, #2563eb); color: white; font-family: 'Press Start 2P', cursive; font-size: 12px;">
            <div style="text-align: center;">
                <div style="width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1rem;"></div>
                <div>Carregando jogo...</div>
            </div>
        </div>
    </div>

    <script>
        // Hide loading screen when React is ready
        function hideLoading() {
            const loading = document.getElementById('loading-screen');
            if (loading) {
                loading.style.display = 'none';
            }
        }
        
        // Check if React is loaded
        function checkReactLoaded() {
            if (typeof React !== 'undefined' && typeof ReactDOM !== 'undefined') {
                hideLoading();
            } else {
                setTimeout(checkReactLoaded, 50);
            }
        }
        
        // Start checking
        window.addEventListener('load', checkReactLoaded);
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const MarioPlatformer = () => {
            const canvasRef = useRef(null);
            const gameLoopRef = useRef(null);
            const [gameState, setGameState] = useState('menu');
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(0);
            const [lives, setLives] = useState(3);
            const [isMobile, setIsMobile] = useState(false);
            const [canvasSize, setCanvasSize] = useState({ width: 800, height: 600 });
            
            const gameRef = useRef({
                player: { x: 100, y: 400, width: 40, height: 50, vx: 0, vy: 0, speed: 5, jumpPower: -15, onGround: false, invulnerable: 0 },
                platforms: [],
                enemies: [],
                coins: [],
                particles: [],
                keys: {},
                camera: { x: 0, y: 0 },
                level: 1
            });

            // Detect mobile and adjust canvas size
            useEffect(() => {
                const checkMobile = () => {
                    const mobile = window.innerWidth <= 768;
                    setIsMobile(mobile);
                    if (mobile) {
                        const maxWidth = window.innerWidth - 40;
                        const aspectRatio = 800 / 600;
                        const width = Math.min(maxWidth, 600);
                        const height = width / aspectRatio;
                        setCanvasSize({ width, height });
                    } else {
                        setCanvasSize({ width: 800, height: 600 });
                    }
                };
                checkMobile();
                window.addEventListener('resize', checkMobile);
                return () => window.removeEventListener('resize', checkMobile);
            }, []);

            useEffect(() => {
                try {
                    const saved = localStorage.getItem('mario-platformer-highscore');
                    if (saved) {
                        setHighScore(parseInt(saved));
                    }
                } catch (error) {
                    // Tracking Prevention or localStorage blocked
                    console.log('High score not available:', error.message);
                }
            }, []);

            const saveHighScore = (score) => {
                try {
                    localStorage.setItem('mario-platformer-highscore', score.toString());
                } catch (error) {
                    // Tracking Prevention or localStorage blocked - silently fail
                    console.log('High score save not available:', error.message);
                }
            };

            const initLevel = () => {
                const game = gameRef.current;
                game.platforms = [];
                game.enemies = [];
                game.coins = [];
                game.particles = [];
                
                // Criar plataformas
                for (let i = 0; i < 20; i++) {
                    game.platforms.push({
                        x: i * 200,
                        y: 500 - (i % 3) * 100,
                        width: 180,
                        height: 20,
                        color: '#8B4513'
                    });
                }
                
                // Criar moedas
                for (let i = 0; i < 15; i++) {
                    game.coins.push({
                        x: 150 + i * 250,
                        y: 300 + Math.sin(i) * 100,
                        width: 30,
                        height: 30,
                        collected: false,
                        rotation: 0
                    });
                }
                
                // Criar inimigos
                for (let i = 0; i < 8; i++) {
                    game.enemies.push({
                        x: 300 + i * 400,
                        y: 450,
                        width: 35,
                        height: 35,
                        vx: -2,
                        direction: -1
                    });
                }
                
                game.player.x = 100;
                game.player.y = 400;
                game.player.vx = 0;
                game.player.vy = 0;
                game.player.invulnerable = 0;
                game.camera.x = 0;
            };

            const startGame = () => {
                setGameState('playing');
                setScore(0);
                setLives(3);
                gameRef.current.level = 1;
                gameRef.current.player.invulnerable = 0;
                initLevel();
            };

            const createParticles = (x, y, color, count = 10) => {
                const game = gameRef.current;
                for (let i = 0; i < count; i++) {
                    game.particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 30,
                        color,
                        size: Math.random() * 4 + 2
                    });
                }
            };

            const checkCollision = (a, b) => {
                return a.x < b.x + b.width &&
                       a.x + a.width > b.x &&
                       a.y < b.y + b.height &&
                       a.y + a.height > b.y;
            };

            const gameLoop = useCallback(() => {
                if (gameState !== 'playing') return;

                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const game = gameRef.current;
                const { player, keys } = game;

                // Clear canvas
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw clouds
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                for (let i = 0; i < 5; i++) {
                    const x = (i * 300 + game.camera.x * 0.3) % (canvas.width + 200) - 100;
                    const y = 50 + i * 30;
                    ctx.beginPath();
                    ctx.arc(x, y, 30, 0, Math.PI * 2);
                    ctx.arc(x + 40, y, 35, 0, Math.PI * 2);
                    ctx.arc(x + 80, y, 30, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Player movement
                if (keys.ArrowLeft || keys.a || keys.A) {
                    player.vx = -player.speed;
                } else if (keys.ArrowRight || keys.d || keys.D) {
                    player.vx = player.speed;
                } else {
                    player.vx *= 0.8;
                }

                if ((keys.ArrowUp || keys.w || keys.W || keys[' ']) && player.onGround) {
                    player.vy = player.jumpPower;
                    player.onGround = false;
                }

                // Apply gravity
                player.vy += 0.8;
                if (player.vy > 15) player.vy = 15;

                // Update invulnerability timer
                if (player.invulnerable > 0) {
                    player.invulnerable--;
                }

                // Update player position
                player.x += player.vx;
                player.y += player.vy;

                // Check platform collisions
                player.onGround = false;
                game.platforms.forEach(platform => {
                    if (checkCollision(player, platform)) {
                        if (player.vy > 0 && player.y < platform.y) {
                            player.y = platform.y - player.height;
                            player.vy = 0;
                            player.onGround = true;
                        }
                    }
                });

                // Update camera
                game.camera.x = player.x - canvas.width / 3;

                // Draw platforms
                game.platforms.forEach(platform => {
                    const px = platform.x - game.camera.x;
                    if (px > -100 && px < canvas.width + 100) {
                        ctx.fillStyle = platform.color;
                        ctx.fillRect(px, platform.y - game.camera.y, platform.width, platform.height);
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(px, platform.y - game.camera.y, platform.width, 5);
                    }
                });

                // Update and draw enemies
                game.enemies = game.enemies.filter(enemy => {
                    enemy.x += enemy.vx;
                    
                    // Bounce off platforms
                    let onPlatform = false;
                    game.platforms.forEach(platform => {
                        if (checkCollision(enemy, platform)) {
                            if (enemy.y < platform.y) {
                                enemy.y = platform.y - enemy.height;
                                onPlatform = true;
                            }
                        }
                    });
                    
                    if (!onPlatform) {
                        enemy.vy += 0.8;
                        enemy.y += enemy.vy;
                    } else {
                        enemy.vy = 0;
                    }
                    
                    // Change direction at edges
                    if (enemy.x < game.camera.x - 50 || enemy.x > game.camera.x + canvas.width + 50) {
                        return false;
                    }
                    
                    const ex = enemy.x - game.camera.x;
                    if (ex > -50 && ex < canvas.width + 50) {
                        ctx.fillStyle = '#8B0000';
                        ctx.fillRect(ex, enemy.y - game.camera.y, enemy.width, enemy.height);
                        ctx.fillStyle = '#FF0000';
                        ctx.fillRect(ex + 5, enemy.y - game.camera.y + 5, enemy.width - 10, enemy.height - 10);
                    }
                    
                    // Check collision with player (apenas se n√£o estiver invulner√°vel)
                    if (checkCollision(player, enemy) && player.invulnerable <= 0) {
                        if (player.vy > 0 && player.y < enemy.y) {
                            // Player jumps on enemy
                            createParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, '#8B0000', 15);
                            setScore(s => s + 50);
                            return false;
                        } else {
                            // Player hit by enemy
                            player.invulnerable = 120; // 2 segundos de invulnerabilidade (60 FPS * 2)
                            setLives(l => {
                                const newLives = l - 1;
                                if (newLives <= 0) {
                                    setGameState('gameOver');
                                    if (score > highScore) {
                                        setHighScore(score);
                                        saveHighScore(score);
                                    }
                                }
                                return newLives;
                            });
                            createParticles(player.x + player.width / 2, player.y + player.height / 2, '#FF0000', 20);
                            player.x = 100;
                            player.y = 400;
                            player.vx = 0;
                            player.vy = 0;
                        }
                    }
                    
                    return true;
                });

                // Update and draw coins
                game.coins.forEach(coin => {
                    if (!coin.collected) {
                        coin.rotation += 0.1;
                        const cx = coin.x - game.camera.x;
                        const cy = coin.y - game.camera.y;
                        
                        if (cx > -50 && cx < canvas.width + 50) {
                            ctx.save();
                            ctx.translate(cx + coin.width / 2, cy + coin.height / 2);
                            ctx.rotate(coin.rotation);
                            ctx.fillStyle = '#FFD700';
                            ctx.shadowColor = '#FFD700';
                            ctx.shadowBlur = 10;
                            ctx.beginPath();
                            ctx.arc(0, 0, coin.width / 2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#FFA500';
                            ctx.beginPath();
                            ctx.arc(0, 0, coin.width / 3, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                            ctx.restore();
                        }
                        
                        if (checkCollision(player, coin)) {
                            coin.collected = true;
                            createParticles(coin.x + coin.width / 2, coin.y + coin.height / 2, '#FFD700', 10);
                            setScore(s => s + 100);
                        }
                    }
                });

                // Update and draw particles
                game.particles = game.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    
                    if (p.life > 0) {
                        const px = p.x - game.camera.x;
                        const py = p.y - game.camera.y;
                        if (px > -10 && px < canvas.width + 10) {
                            ctx.fillStyle = p.color;
                            ctx.globalAlpha = p.life / 30;
                            ctx.fillRect(px, py, p.size, p.size);
                            ctx.globalAlpha = 1;
                        }
                        return true;
                    }
                    return false;
                });

                // Draw player (piscar quando invulner√°vel)
                const px = player.x - game.camera.x;
                const py = player.y - game.camera.y;
                if (player.invulnerable <= 0 || Math.floor(player.invulnerable / 10) % 2 === 0) {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(px, py, player.width, player.height);
                    ctx.fillStyle = '#0000FF';
                    ctx.fillRect(px + 5, py + 5, player.width - 10, 15);
                    ctx.fillStyle = '#FFFF00';
                    ctx.fillRect(px + 10, py + 20, 20, 20);
                }

                // Check if player fell (verificar posi√ß√£o relativa √† c√¢mera, n√£o absoluta)
                const playerScreenY = player.y - game.camera.y;
                if (playerScreenY > canvas.height + 100) {
                    setLives(l => {
                        const newLives = l - 1;
                        if (newLives <= 0) {
                            setGameState('gameOver');
                            if (score > highScore) {
                                setHighScore(score);
                                saveHighScore(score);
                            }
                        }
                        return newLives;
                    });
                    player.x = 100;
                    player.y = 400;
                    player.vx = 0;
                    player.vy = 0;
                }

                gameLoopRef.current = requestAnimationFrame(gameLoop);
            }, [gameState, score, highScore]);

            useEffect(() => {
                if (gameState === 'playing') {
                    gameLoopRef.current = requestAnimationFrame(gameLoop);
                }
                return () => {
                    if (gameLoopRef.current) {
                        cancelAnimationFrame(gameLoopRef.current);
                    }
                };
            }, [gameState, gameLoop]);

            // Touch controls handlers
            const handleTouchStart = (direction) => {
                const game = gameRef.current;
                if (direction === 'left' || direction === 'a') game.keys.ArrowLeft = true;
                if (direction === 'right' || direction === 'd') game.keys.ArrowRight = true;
                if (direction === 'jump' || direction === 'w' || direction === ' ') {
                    if (game.player.onGround) {
                        game.player.vy = game.player.jumpPower;
                        game.player.onGround = false;
                    }
                }
            };

            const handleTouchEnd = (direction) => {
                const game = gameRef.current;
                if (direction === 'left' || direction === 'a') game.keys.ArrowLeft = false;
                if (direction === 'right' || direction === 'd') game.keys.ArrowRight = false;
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'a', 'A', 'd', 'D', 'w', 'W', ' '].includes(e.key)) {
                        e.preventDefault();
                    }
                    gameRef.current.keys[e.key] = true;
                };

                const handleKeyUp = (e) => {
                    gameRef.current.keys[e.key] = false;
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);

                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, [gameState]);

            return (
                <div style={{ minHeight: '100vh', background: 'linear-gradient(to bottom right, #60a5fa, #3b82f6, #2563eb)', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '1rem', fontFamily: "'Press Start 2P', cursive" }}>
                    <div className="relative">
                        {/* HUD */}
                        <div style={{ position: 'absolute', top: 0, left: 0, right: 0, display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', padding: '1rem', color: 'white', zIndex: 10, fontSize: '12px' }}>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <span style={{ color: '#facc15' }}>üí∞</span>
                                    <span>{score}</span>
                                </div>
                                <div style={{ display: 'flex', gap: '0.25rem' }}>
                                    {[...Array(lives)].map((_, i) => (
                                        <div key={i} style={{ width: '24px', height: '24px', backgroundColor: '#ef4444', border: '2px solid #fca5a5' }} />
                                    ))}
                                </div>
                            </div>
                            
                            <div style={{ textAlign: 'right', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                <div style={{ fontSize: '12px', color: '#d1d5db' }}>RECORDE</div>
                                <div style={{ color: '#facc15' }}>{highScore}</div>
                            </div>
                        </div>

                        <canvas
                            ref={canvasRef}
                            width={canvasSize.width}
                            height={canvasSize.height}
                            style={{ border: '4px solid #2563eb', boxShadow: '0 0 30px rgba(37, 99, 235, 0.5), 0 25px 50px -12px rgba(0, 0, 0, 0.25)', backgroundColor: '#93c5fd', maxWidth: '100%', height: 'auto' }}
                        />

                        {/* Touch Controls for Mobile */}
                        {isMobile && gameState === 'playing' && (
                            <div className="touch-controls">
                                <div className="dpad">
                                    <button 
                                        className="up"
                                        onTouchStart={(e) => { e.preventDefault(); handleTouchStart('jump'); }}
                                        onMouseDown={() => handleTouchStart('jump')}
                                    >‚Üë</button>
                                    <button 
                                        className="left"
                                        onTouchStart={(e) => { e.preventDefault(); handleTouchStart('left'); }}
                                        onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd('left'); }}
                                        onMouseDown={() => handleTouchStart('left')}
                                        onMouseUp={() => handleTouchEnd('left')}
                                        onMouseLeave={() => handleTouchEnd('left')}
                                    >‚Üê</button>
                                    <div></div>
                                    <button 
                                        className="right"
                                        onTouchStart={(e) => { e.preventDefault(); handleTouchStart('right'); }}
                                        onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd('right'); }}
                                        onMouseDown={() => handleTouchStart('right')}
                                        onMouseUp={() => handleTouchEnd('right')}
                                        onMouseLeave={() => handleTouchEnd('right')}
                                    >‚Üí</button>
                                </div>
                            </div>
                        )}

                        {/* Menu Overlay */}
                        {gameState === 'menu' && (
                            <div style={{ position: 'absolute', inset: 0, backgroundColor: 'rgba(0, 0, 0, 0.9)', display: 'flex', alignItems: 'center', justifyContent: 'center', backdropFilter: 'blur(4px)' }}>
                                <div style={{ textAlign: 'center', display: 'flex', flexDirection: 'column', gap: '2rem', padding: '2rem' }}>
                                    <h1 style={{ fontSize: '3rem', background: 'linear-gradient(to right, #ef4444, #facc15, #ef4444)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', backgroundClip: 'text', animation: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite' }}>
                                        MARIO<br/>PLATFORMER
                                    </h1>
                                    
                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', fontSize: '12px', color: '#93c5fd' }}>
                                        <p>A/D ou SETAS - Mover</p>
                                        <p>W ou SETA CIMA ou ESPA√áO - Pular</p>
                                        <p>Colete moedas e elimine inimigos!</p>
                                    </div>

                                    <button
                                        onClick={startGame}
                                        style={{ background: 'linear-gradient(to right, #ef4444, #dc2626)', color: 'white', padding: '1rem 2rem', fontSize: '14px', border: '4px solid white', boxShadow: '0 0 20px rgba(239, 68, 68, 0.5)', cursor: 'pointer', transition: 'all 0.3s' }}
                                        onMouseEnter={(e) => { e.target.style.transform = 'scale(1.1)'; e.target.style.background = 'linear-gradient(to right, #f87171, #ef4444)'; }}
                                        onMouseLeave={(e) => { e.target.style.transform = 'scale(1)'; e.target.style.background = 'linear-gradient(to right, #ef4444, #dc2626)'; }}
                                        onMouseDown={(e) => { e.target.style.transform = 'scale(0.95)'; }}
                                        onMouseUp={(e) => { e.target.style.transform = 'scale(1.1)'; }}
                                    >
                                        INICIAR
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Game Over Overlay */}
                        {gameState === 'gameOver' && (
                            <div style={{ position: 'absolute', inset: 0, backgroundColor: 'rgba(0, 0, 0, 0.9)', display: 'flex', alignItems: 'center', justifyContent: 'center', backdropFilter: 'blur(4px)' }}>
                                <div style={{ textAlign: 'center', display: 'flex', flexDirection: 'column', gap: '1.5rem', padding: '2rem' }}>
                                    <h2 style={{ fontSize: '2.25rem', color: '#ef4444', animation: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite' }}>GAME OVER</h2>
                                    
                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', fontSize: '1.25rem' }}>
                                        <div>
                                            <div style={{ fontSize: '12px', color: '#9ca3af', marginBottom: '0.25rem' }}>PONTUA√á√ÉO</div>
                                            <div style={{ color: '#facc15' }}>{score}</div>
                                        </div>
                                        
                                        {score === highScore && score > 0 && (
                                            <div style={{ color: '#facc15', fontSize: '14px', animation: 'bounce 1s infinite' }}>
                                                üèÜ NOVO RECORDE! üèÜ
                                            </div>
                                        )}
                                        
                                        <div>
                                            <div style={{ fontSize: '12px', color: '#9ca3af', marginBottom: '0.25rem' }}>RECORDE</div>
                                            <div style={{ color: '#facc15' }}>{highScore}</div>
                                        </div>
                                    </div>

                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem', paddingTop: '1rem' }}>
                                        <button
                                            onClick={startGame}
                                            style={{ width: '100%', background: 'linear-gradient(to right, #16a34a, #15803d)', color: 'white', padding: '0.75rem 2rem', fontSize: '12px', border: '2px solid white', cursor: 'pointer', transition: 'all 0.3s' }}
                                            onMouseEnter={(e) => { e.target.style.transform = 'scale(1.05)'; e.target.style.background = 'linear-gradient(to right, #22c55e, #16a34a)'; }}
                                            onMouseLeave={(e) => { e.target.style.transform = 'scale(1)'; e.target.style.background = 'linear-gradient(to right, #16a34a, #15803d)'; }}
                                        >
                                            JOGAR NOVAMENTE
                                        </button>
                                        <button
                                            onClick={() => setGameState('menu')}
                                            style={{ width: '100%', backgroundColor: '#b91c1c', color: 'white', padding: '0.75rem 2rem', fontSize: '12px', border: '2px solid #f87171', cursor: 'pointer', transition: 'background-color 0.3s' }}
                                            onMouseEnter={(e) => { e.target.style.backgroundColor = '#dc2626'; }}
                                            onMouseLeave={(e) => { e.target.style.backgroundColor = '#b91c1c'; }}
                                        >
                                            MENU
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        ReactDOM.render(React.createElement(MarioPlatformer), document.getElementById('root'));
        hideLoading();
    </script>
</body>
</html>

