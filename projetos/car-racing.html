<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO Meta Tags -->
    <title>Car Racing - Jogo React | Dev Brayan - Portfolio</title>
    <meta name="title" content="Car Racing - Jogo React | Dev Brayan">
    <meta name="description" content="Jogue Car Racing, um jogo de corrida de carros desenvolvido em React. Evite obst√°culos, colete moedas e alcance a maior velocidade. Desenvolvido por Dev Brayan.">
    <meta name="description:en" content="Play Car Racing, a car racing game developed in React. Avoid obstacles, collect coins and reach the highest speed. Developed by Dev Brayan.">
    <meta name="keywords" content="Car Racing, Jogo React, Game React, Racing Game, Car Game, React Game, Dev Brayan, Brayan Silveira, Portfolio Game, Interactive Game, Browser Game, HTML5 Game, Canvas Game, JavaScript Game, React Developer, Game Developer, Web Game, Online Game, Free Game, Play Game">
    <meta name="author" content="Brayan Rosa da Silveira - Dev Brayan">
    <meta name="robots" content="index, follow">
    <meta name="language" content="Portuguese, English">
    
    <!-- Multilingual Support -->
    <link rel="alternate" hreflang="pt-BR" href="https://brayansilver.github.io/projetos/car-racing.html">
    <link rel="alternate" hreflang="en" href="https://brayansilver.github.io/projetos/car-racing.html">
    <link rel="alternate" hreflang="x-default" href="https://brayansilver.github.io/projetos/car-racing.html">
    
    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Car Racing - Jogo React | Dev Brayan">
    <meta property="og:description" content="Jogue Car Racing, um jogo de corrida de carros desenvolvido em React. Desenvolvido por Dev Brayan.">
    <meta property="og:locale" content="pt_BR">
    <meta property="og:locale:alternate" content="en_US">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Car Racing - Jogo React | Dev Brayan">
    <meta name="twitter:description" content="Jogue Car Racing, um jogo de corrida de carros desenvolvido em React.">
    
    <!-- Performance Optimizations -->
    <link rel="preconnect" href="https://unpkg.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- Load fonts asynchronously -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
    <noscript><link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet"></noscript>
    
    <!-- Load React and dependencies in correct order -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
            overflow: hidden;
        }
        #root {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            max-width: 100%;
            max-height: 100vh;
            width: auto !important;
            height: auto !important;
        }
        @media (max-width: 768px) {
            canvas {
                width: 100vw !important;
                height: auto !important;
            }
        }
        .touch-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
            pointer-events: none;
        }
        .touch-controls button {
            pointer-events: all;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid white;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        .touch-controls .dpad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 180px;
            height: 180px;
        }
        .touch-controls .dpad button {
            width: 58px;
            height: 58px;
            border-radius: 8px;
        }
        .touch-controls .dpad .left { grid-column: 1; grid-row: 2; }
        .touch-controls .dpad .right { grid-column: 3; grid-row: 2; }
        @media (min-width: 769px) {
            .touch-controls {
                display: none;
            }
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
    </style>
</head>
<body>
    <div id="root">
        <div id="loading-screen" style="display: flex; align-items: center; justify-content: center; height: 100vh; background: linear-gradient(to bottom right, #1f2937, #111827, #000000); color: white; font-family: 'Press Start 2P', cursive; font-size: 12px;">
            <div style="text-align: center;">
                <div style="width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1rem;"></div>
                <div>Carregando jogo...</div>
            </div>
        </div>
    </div>

    <script>
        // Hide loading screen when React is ready
        function hideLoading() {
            const loading = document.getElementById('loading-screen');
            if (loading) {
                loading.style.display = 'none';
            }
        }
        
        // Check if React is loaded
        function checkReactLoaded() {
            if (typeof React !== 'undefined' && typeof ReactDOM !== 'undefined') {
                hideLoading();
            } else {
                setTimeout(checkReactLoaded, 50);
            }
        }
        
        // Start checking
        window.addEventListener('load', checkReactLoaded);
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const CarRacing = () => {
            const canvasRef = useRef(null);
            const gameLoopRef = useRef(null);
            const [gameState, setGameState] = useState('menu');
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(0);
            const [speed, setSpeed] = useState(0);
            const [isMobile, setIsMobile] = useState(false);
            const [canvasSize, setCanvasSize] = useState({ width: 800, height: 600 });
            
            const gameRef = useRef({
                player: { x: 400, y: 500, width: 50, height: 80, angle: 0, invulnerable: 0 },
                road: { offset: 0, lines: [] },
                obstacles: [],
                coins: [],
                particles: [],
                keys: {},
                gameSpeed: 3
            });

            // Detect mobile and adjust canvas size
            useEffect(() => {
                const checkMobile = () => {
                    const mobile = window.innerWidth <= 768;
                    setIsMobile(mobile);
                    if (mobile) {
                        const maxWidth = window.innerWidth - 40;
                        const aspectRatio = 800 / 600;
                        const width = Math.min(maxWidth, 600);
                        const height = width / aspectRatio;
                        setCanvasSize({ width, height });
                    } else {
                        setCanvasSize({ width: 800, height: 600 });
                    }
                };
                checkMobile();
                window.addEventListener('resize', checkMobile);
                return () => window.removeEventListener('resize', checkMobile);
            }, []);

            useEffect(() => {
                try {
                    const saved = localStorage.getItem('car-racing-highscore');
                    if (saved) {
                        setHighScore(parseInt(saved));
                    }
                } catch (error) {
                    console.log('No high score found');
                }
            }, []);

            const saveHighScore = (score) => {
                try {
                    localStorage.setItem('car-racing-highscore', score.toString());
                } catch (error) {
                    // Tracking Prevention or localStorage blocked - silently fail
                    console.log('High score save not available:', error.message);
                }
            };

            const startGame = () => {
                setGameState('playing');
                setScore(0);
                setSpeed(0);
                
                const game = gameRef.current;
                game.player = { x: 400, y: 500, width: 50, height: 80, angle: 0, invulnerable: 0 };
                game.road = { offset: 0, lines: [] };
                game.obstacles = [];
                game.coins = [];
                game.particles = [];
                game.gameSpeed = 3;
                
                // Initialize road lines
                for (let i = 0; i < 20; i++) {
                    game.road.lines.push(i * 100);
                }
            };

            const createParticles = (x, y, color, count = 15) => {
                const game = gameRef.current;
                for (let i = 0; i < count; i++) {
                    game.particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 40,
                        color,
                        size: Math.random() * 5 + 3
                    });
                }
            };

            const spawnObstacle = () => {
                const game = gameRef.current;
                const lanes = [150, 300, 450, 600];
                const lane = lanes[Math.floor(Math.random() * lanes.length)];
                
                game.obstacles.push({
                    x: lane,
                    y: -100,
                    width: 60,
                    height: 100,
                    type: Math.random() > 0.7 ? 'truck' : 'car',
                    color: `hsl(${Math.random() * 360}, 70%, 50%)`
                });
            };

            const spawnCoin = () => {
                const game = gameRef.current;
                const lanes = [150, 300, 450, 600];
                const lane = lanes[Math.floor(Math.random() * lanes.length)];
                
                game.coins.push({
                    x: lane,
                    y: -50,
                    width: 40,
                    height: 40,
                    rotation: 0,
                    collected: false
                });
            };

            const checkCollision = (a, b) => {
                return a.x < b.x + b.width &&
                       a.x + a.width > b.x &&
                       a.y < b.y + b.height &&
                       a.y + a.height > b.y;
            };

            const gameLoop = useCallback(() => {
                if (gameState !== 'playing') return;

                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const game = gameRef.current;
                const { player, keys } = game;

                // Update invulnerability timer
                if (player.invulnerable > 0) {
                    player.invulnerable--;
                }

                // Increase game speed over time (mais lento)
                game.gameSpeed += 0.005;
                if (game.gameSpeed > 10) game.gameSpeed = 10;
                setSpeed(Math.floor(game.gameSpeed * 10));

                // Update score
                setScore(s => s + 1);

                // Clear canvas
                ctx.fillStyle = '#2d5016';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw road
                ctx.fillStyle = '#404040';
                ctx.fillRect(100, 0, 600, canvas.height);

                // Draw road lines
                ctx.strokeStyle = '#FFFF00';
                ctx.lineWidth = 4;
                ctx.setLineDash([20, 20]);
                
                game.road.offset += game.gameSpeed;
                if (game.road.offset > 100) game.road.offset = 0;
                
                for (let i = -2; i < 20; i++) {
                    const y = i * 100 - game.road.offset;
                    ctx.beginPath();
                    ctx.moveTo(400, y);
                    ctx.lineTo(400, y + 50);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // Draw road borders
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(95, 0, 10, canvas.height);
                ctx.fillRect(695, 0, 10, canvas.height);

                // Player movement (mais suave)
                if (keys.ArrowLeft || keys.a || keys.A) {
                    player.x -= 6;
                    player.angle = -0.2;
                } else if (keys.ArrowRight || keys.d || keys.D) {
                    player.x += 6;
                    player.angle = 0.2;
                } else {
                    player.angle *= 0.8;
                }

                // Keep player on road
                if (player.x < 120) player.x = 120;
                if (player.x > canvas.width - player.width - 120) player.x = canvas.width - player.width - 120;

                // Spawn obstacles (menos frequente)
                if (Math.random() < 0.012) {
                    spawnObstacle();
                }

                // Spawn coins (menos frequente)
                if (Math.random() < 0.01) {
                    spawnCoin();
                }

                // Update and draw obstacles
                game.obstacles = game.obstacles.filter(obstacle => {
                    obstacle.y += game.gameSpeed;

                    const ox = obstacle.x;
                    const oy = obstacle.y;

                    // Draw obstacle
                    ctx.save();
                    ctx.translate(ox + obstacle.width / 2, oy + obstacle.height / 2);
                    ctx.fillStyle = obstacle.color;
                    ctx.fillRect(-obstacle.width / 2, -obstacle.height / 2, obstacle.width, obstacle.height);
                    
                    // Draw windows
                    ctx.fillStyle = '#87CEEB';
                    if (obstacle.type === 'truck') {
                        ctx.fillRect(-obstacle.width / 2 + 5, -obstacle.height / 2 + 5, obstacle.width - 10, 30);
                    } else {
                        ctx.fillRect(-obstacle.width / 2 + 5, -obstacle.height / 2 + 5, obstacle.width - 10, 20);
                    }
                    
                    // Draw wheels
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(-obstacle.width / 2 - 5, obstacle.height / 2 - 15, 10, 15);
                    ctx.fillRect(obstacle.width / 2 - 5, obstacle.height / 2 - 15, 10, 15);
                    ctx.restore();

                    // Check collision with player (apenas se n√£o estiver invulner√°vel)
                    if (checkCollision(player, obstacle) && player.invulnerable <= 0) {
                        player.invulnerable = 60; // 1 segundo de invulnerabilidade ap√≥s colis√£o
                        createParticles(player.x + player.width / 2, player.y + player.height / 2, '#FF0000', 30);
                        // Colis√£o termina o jogo (comportamento original do jogo)
                        setGameState('gameOver');
                        if (score > highScore) {
                            setHighScore(score);
                            saveHighScore(score);
                        }
                        return false;
                    }

                    return obstacle.y < canvas.height + 100;
                });

                // Update and draw coins
                game.coins.forEach(coin => {
                    if (!coin.collected) {
                        coin.y += game.gameSpeed;
                        coin.rotation += 0.15;

                        const cx = coin.x;
                        const cy = coin.y;

                        ctx.save();
                        ctx.translate(cx + coin.width / 2, cy + coin.height / 2);
                        ctx.rotate(coin.rotation);
                        ctx.fillStyle = '#FFD700';
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.arc(0, 0, coin.width / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#FFA500';
                        ctx.beginPath();
                        ctx.arc(0, 0, coin.width / 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.restore();

                        if (checkCollision(player, coin)) {
                            coin.collected = true;
                            createParticles(coin.x + coin.width / 2, coin.y + coin.height / 2, '#FFD700', 15);
                            setScore(s => s + 500);
                        }
                    }
                });

                // Update and draw particles
                game.particles = game.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    
                    if (p.life > 0) {
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.life / 40;
                        ctx.fillRect(p.x, p.y, p.size, p.size);
                        ctx.globalAlpha = 1;
                        return true;
                    }
                    return false;
                });

                // Draw player car (piscar quando invulner√°vel)
                ctx.save();
                ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
                ctx.rotate(player.angle);
                
                if (player.invulnerable <= 0 || Math.floor(player.invulnerable / 10) % 2 === 0) {
                    // Car body
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height);
                    
                    // Car windows
                    ctx.fillStyle = '#87CEEB';
                    ctx.fillRect(-player.width / 2 + 5, -player.height / 2 + 5, player.width - 10, 25);
                    
                    // Car details
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(-player.width / 2, -player.height / 2, player.width, 5);
                    ctx.fillRect(-player.width / 2, player.height / 2 - 5, player.width, 5);
                    
                    // Wheels
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(-player.width / 2 - 8, player.height / 2 - 20, 12, 20);
                    ctx.fillRect(player.width / 2 - 4, player.height / 2 - 20, 12, 20);
                    ctx.fillRect(-player.width / 2 - 8, -player.height / 2, 12, 20);
                    ctx.fillRect(player.width / 2 - 4, -player.height / 2, 12, 20);
                }
                
                ctx.restore();

                gameLoopRef.current = requestAnimationFrame(gameLoop);
            }, [gameState, score, highScore]);

            useEffect(() => {
                if (gameState === 'playing') {
                    gameLoopRef.current = requestAnimationFrame(gameLoop);
                }
                return () => {
                    if (gameLoopRef.current) {
                        cancelAnimationFrame(gameLoopRef.current);
                    }
                };
            }, [gameState, gameLoop]);

            // Touch controls handlers
            const handleTouchStart = (direction) => {
                const game = gameRef.current;
                if (direction === 'left' || direction === 'a') game.keys.ArrowLeft = true;
                if (direction === 'right' || direction === 'd') game.keys.ArrowRight = true;
            };

            const handleTouchEnd = (direction) => {
                const game = gameRef.current;
                if (direction === 'left' || direction === 'a') game.keys.ArrowLeft = false;
                if (direction === 'right' || direction === 'd') game.keys.ArrowRight = false;
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (['ArrowLeft', 'ArrowRight', 'a', 'A', 'd', 'D'].includes(e.key)) {
                        e.preventDefault();
                    }
                    gameRef.current.keys[e.key] = true;
                };

                const handleKeyUp = (e) => {
                    gameRef.current.keys[e.key] = false;
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);

                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, [gameState]);

            return (
                <div style={{ minHeight: '100vh', background: 'linear-gradient(to bottom right, #1f2937, #111827, #000000)', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '1rem', fontFamily: "'Press Start 2P', cursive" }}>
                    <div style={{ position: 'relative' }}>
                        {/* HUD */}
                        <div style={{ position: 'absolute', top: 0, left: 0, right: 0, display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', padding: '1rem', color: 'white', zIndex: 10, fontSize: '12px' }}>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <span style={{ color: '#facc15' }}>üí∞</span>
                                    <span>{score}</span>
                                </div>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <span style={{ color: '#22d3ee' }}>‚ö°</span>
                                    <span>{speed} km/h</span>
                                </div>
                            </div>
                            
                            <div style={{ textAlign: 'right', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                <div style={{ fontSize: '12px', color: '#d1d5db' }}>RECORDE</div>
                                <div style={{ color: '#facc15' }}>{highScore}</div>
                            </div>
                        </div>

                        <canvas
                            ref={canvasRef}
                            width={canvasSize.width}
                            height={canvasSize.height}
                            style={{ border: '4px solid #4b5563', boxShadow: '0 0 30px rgba(0, 0, 0, 0.5), 0 25px 50px -12px rgba(0, 0, 0, 0.25)', backgroundColor: '#1f2937', maxWidth: '100%', height: 'auto' }}
                        />

                        {/* Touch Controls for Mobile */}
                        {isMobile && gameState === 'playing' && (
                            <div className="touch-controls">
                                <div className="dpad">
                                    <button 
                                        className="left"
                                        onTouchStart={(e) => { e.preventDefault(); handleTouchStart('left'); }}
                                        onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd('left'); }}
                                        onMouseDown={() => handleTouchStart('left')}
                                        onMouseUp={() => handleTouchEnd('left')}
                                        onMouseLeave={() => handleTouchEnd('left')}
                                    >‚Üê</button>
                                    <button 
                                        className="right"
                                        onTouchStart={(e) => { e.preventDefault(); handleTouchStart('right'); }}
                                        onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd('right'); }}
                                        onMouseDown={() => handleTouchStart('right')}
                                        onMouseUp={() => handleTouchEnd('right')}
                                        onMouseLeave={() => handleTouchEnd('right')}
                                    >‚Üí</button>
                                </div>
                            </div>
                        )}

                        {/* Menu Overlay */}
                        {gameState === 'menu' && (
                            <div style={{ position: 'absolute', inset: 0, backgroundColor: 'rgba(0, 0, 0, 0.9)', display: 'flex', alignItems: 'center', justifyContent: 'center', backdropFilter: 'blur(4px)' }}>
                                <div style={{ textAlign: 'center', display: 'flex', flexDirection: 'column', gap: '2rem', padding: '2rem' }}>
                                    <h1 style={{ fontSize: '3rem', background: 'linear-gradient(to right, #ef4444, #facc15, #ef4444)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', backgroundClip: 'text', animation: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite' }}>
                                        CAR<br/>RACING
                                    </h1>
                                    
                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', fontSize: '12px', color: '#67e8f9' }}>
                                        <p>A/D ou SETAS - Mover</p>
                                        <p>Evite os obst√°culos!</p>
                                        <p>Colete moedas para pontos extras!</p>
                                    </div>

                                    <button
                                        onClick={startGame}
                                        style={{ background: 'linear-gradient(to right, #ef4444, #dc2626)', color: 'white', padding: '1rem 2rem', fontSize: '14px', border: '4px solid white', boxShadow: '0 0 20px rgba(239, 68, 68, 0.5)', cursor: 'pointer', transition: 'all 0.3s' }}
                                        onMouseEnter={(e) => { e.target.style.transform = 'scale(1.1)'; e.target.style.background = 'linear-gradient(to right, #f87171, #ef4444)'; }}
                                        onMouseLeave={(e) => { e.target.style.transform = 'scale(1)'; e.target.style.background = 'linear-gradient(to right, #ef4444, #dc2626)'; }}
                                        onMouseDown={(e) => { e.target.style.transform = 'scale(0.95)'; }}
                                        onMouseUp={(e) => { e.target.style.transform = 'scale(1.1)'; }}
                                    >
                                        INICIAR
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Game Over Overlay */}
                        {gameState === 'gameOver' && (
                            <div style={{ position: 'absolute', inset: 0, backgroundColor: 'rgba(0, 0, 0, 0.9)', display: 'flex', alignItems: 'center', justifyContent: 'center', backdropFilter: 'blur(4px)' }}>
                                <div style={{ textAlign: 'center', display: 'flex', flexDirection: 'column', gap: '1.5rem', padding: '2rem' }}>
                                    <h2 style={{ fontSize: '2.25rem', color: '#ef4444', animation: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite' }}>GAME OVER</h2>
                                    
                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', fontSize: '1.25rem' }}>
                                        <div>
                                            <div style={{ fontSize: '12px', color: '#9ca3af', marginBottom: '0.25rem' }}>PONTUA√á√ÉO</div>
                                            <div style={{ color: '#facc15' }}>{score}</div>
                                        </div>
                                        
                                        {score === highScore && score > 0 && (
                                            <div style={{ color: '#facc15', fontSize: '14px', animation: 'bounce 1s infinite' }}>
                                                üèÜ NOVO RECORDE! üèÜ
                                            </div>
                                        )}
                                        
                                        <div>
                                            <div style={{ fontSize: '12px', color: '#9ca3af', marginBottom: '0.25rem' }}>RECORDE</div>
                                            <div style={{ color: '#facc15' }}>{highScore}</div>
                                        </div>
                                    </div>

                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem', paddingTop: '1rem' }}>
                                        <button
                                            onClick={startGame}
                                            style={{ width: '100%', background: 'linear-gradient(to right, #16a34a, #15803d)', color: 'white', padding: '0.75rem 2rem', fontSize: '12px', border: '2px solid white', cursor: 'pointer', transition: 'all 0.3s' }}
                                            onMouseEnter={(e) => { e.target.style.transform = 'scale(1.05)'; e.target.style.background = 'linear-gradient(to right, #22c55e, #16a34a)'; }}
                                            onMouseLeave={(e) => { e.target.style.transform = 'scale(1)'; e.target.style.background = 'linear-gradient(to right, #16a34a, #15803d)'; }}
                                        >
                                            JOGAR NOVAMENTE
                                        </button>
                                        <button
                                            onClick={() => setGameState('menu')}
                                            style={{ width: '100%', backgroundColor: '#b91c1c', color: 'white', padding: '0.75rem 2rem', fontSize: '12px', border: '2px solid #f87171', cursor: 'pointer', transition: 'background-color 0.3s' }}
                                            onMouseEnter={(e) => { e.target.style.backgroundColor = '#dc2626'; }}
                                            onMouseLeave={(e) => { e.target.style.backgroundColor = '#b91c1c'; }}
                                        >
                                            MENU
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        ReactDOM.render(React.createElement(CarRacing), document.getElementById('root'));
        hideLoading();
    </script>
</body>
</html>

